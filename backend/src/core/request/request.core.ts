/**
 * RequestCore - CRUD operations, status management, attachments
 * ~250 lines
 * Dependencies: DatabaseWrapper only
 */

import { v4 as uuidv4 } from 'uuid';
import { DatabaseWrapper } from '../../platform';
import {
  RequestCoreInterface,
  Request,
  RequestInput,
  RequestStatus,
  WorkflowStep,
  Attachment,
  AttachmentInput,
  TimelineEntry,
} from './request.types';
import { UserRole } from '../../shared/types';

export class RequestCore implements RequestCoreInterface {
  private db: DatabaseWrapper;

  constructor(db: DatabaseWrapper) {
    this.db = db;
  }

  /**
   * Create a new request with items
   * Request number is auto-generated via database trigger
   */
  async createRequest(creatorId: string, data: RequestInput): Promise<Request> {
    // Get creator's company ID for the request
    const creator = await this.db.queryOne<any>(
      'SELECT company_id, role FROM users WHERE id = $1',
      [creatorId]
    );

    if (!creator) {
      throw new Error('Creator not found');
    }

    // Validate department belongs to company
    const department = await this.db.queryOne<any>(
      'SELECT company_id FROM departments WHERE id = $1',
      [data.departmentId]
    );

    if (!department) {
      throw new Error('Department not found');
    }

    if (department.company_id !== creator.company_id) {
      throw new Error('Department does not belong to creator company');
    }

    // Create request (request_number is auto-generated by trigger)
    const request = await this.db.insert<any>('requests', {
      id: uuidv4(),
      creator_id: creatorId,
      department_id: data.departmentId,
      company_id: creator.company_id,
      status: RequestStatus.PENDING,
      current_step: null, // Will be set when workflow is created
      items: JSON.stringify(data.items),
      notes: data.notes || null,
    });

    return this.mapRowToRequest(request);
  }

  /**
   * Get request by ID
   */
  async getRequestById(id: string): Promise<Request | null> {
    const row = await this.db.queryOne<any>(
      'SELECT * FROM requests WHERE id = $1',
      [id]
    );

    return row ? this.mapRowToRequest(row) : null;
  }

  /**
   * Get all requests for a department
   * Used by Managers to see all department requests
   */
  async getRequestsByDepartment(departmentId: string): Promise<Request[]> {
    const rows = await this.db.query<any>(
      'SELECT * FROM requests WHERE department_id = $1 ORDER BY created_at DESC',
      [departmentId]
    );

    return rows.map(this.mapRowToRequest);
  }

  /**
   * Get requests created by a specific user
   * Used by Staff to see their own requests
   */
  async getRequestsByCreator(creatorId: string): Promise<Request[]> {
    const rows = await this.db.query<any>(
      'SELECT * FROM requests WHERE creator_id = $1 ORDER BY created_at DESC',
      [creatorId]
    );

    return rows.map(this.mapRowToRequest);
  }

  /**
   * Get pending requests for a specific workflow step
   * Used by Contrôleur, Direction, Économe to see all company requests
   */
  async getPendingRequestsForApprover(
    companyId: string,
    currentStep: WorkflowStep
  ): Promise<Request[]> {
    const rows = await this.db.query<any>(
      `SELECT * FROM requests
       WHERE company_id = $1
         AND status = $2
         AND current_step = $3
       ORDER BY created_at DESC`,
      [companyId, RequestStatus.PENDING, currentStep]
    );

    return rows.map(this.mapRowToRequest);
  }

  /**
   * Update request status and optionally current step
   */
  async updateRequestStatus(
    id: string,
    status: RequestStatus,
    currentStep?: WorkflowStep | null
  ): Promise<void> {
    const updates: any = { status };

    if (currentStep !== undefined) {
      updates.current_step = currentStep;
    }

    await this.db.update('requests', id, updates);
  }

  /**
   * Add attachment to request
   * File should already be uploaded to storage (via StorageWrapper)
   */
  async addAttachment(
    requestId: string,
    uploadedBy: string,
    file: AttachmentInput
  ): Promise<Attachment> {
    // Verify request exists
    const request = await this.getRequestById(requestId);
    if (!request) {
      throw new Error('Request not found');
    }

    const attachment = await this.db.insert<any>('attachments', {
      id: uuidv4(),
      request_id: requestId,
      file_name: file.fileName,
      file_url: file.fileUrl,
      file_size: file.fileSize,
      mime_type: file.mimeType,
      uploaded_by: uploadedBy,
    });

    return this.mapRowToAttachment(attachment);
  }

  /**
   * Get all attachments for a request
   */
  async getAttachments(requestId: string): Promise<Attachment[]> {
    const rows = await this.db.query<any>(
      'SELECT * FROM attachments WHERE request_id = $1 ORDER BY created_at ASC',
      [requestId]
    );

    return rows.map(this.mapRowToAttachment);
  }

  /**
   * Get request timeline (chronological history)
   * Combines request creation, approvals, comments, and attachments
   */
  async getRequestTimeline(requestId: string): Promise<TimelineEntry[]> {
    const timeline: TimelineEntry[] = [];

    // Get request creation
    const request = await this.db.queryOne<any>(
      `SELECT r.*, u.first_name, u.last_name, u.role
       FROM requests r
       JOIN users u ON r.creator_id = u.id
       WHERE r.id = $1`,
      [requestId]
    );

    if (!request) {
      throw new Error('Request not found');
    }

    timeline.push({
      id: uuidv4(),
      timestamp: new Date(request.created_at),
      type: 'created',
      actor: {
        id: request.creator_id,
        name: `${request.first_name} ${request.last_name}`,
        role: request.role as UserRole,
      },
      description: 'Request created',
      metadata: {
        requestNumber: request.request_number,
        itemCount: JSON.parse(request.items).length,
      },
    });

    // Get approvals
    const approvals = await this.db.query<any>(
      `SELECT a.*, u.first_name, u.last_name, u.role
       FROM approvals a
       JOIN users u ON a.approver_id = u.id
       WHERE a.request_id = $1
       ORDER BY a.timestamp ASC`,
      [requestId]
    );

    for (const approval of approvals) {
      timeline.push({
        id: approval.id,
        timestamp: new Date(approval.timestamp),
        type: approval.status === 'APPROVED' ? 'approved' : 'rejected',
        actor: {
          id: approval.approver_id,
          name: `${approval.first_name} ${approval.last_name}`,
          role: approval.role as UserRole,
        },
        description:
          approval.status === 'APPROVED'
            ? `Approved by ${approval.step_role}`
            : `Rejected by ${approval.step_role}`,
        metadata: {
          stepRole: approval.step_role,
          rejectionReason: approval.rejection_reason,
          additionalData: approval.additional_data || null,
        },
      });
    }

    // Get comments
    const comments = await this.db.query<any>(
      `SELECT c.*, u.first_name, u.last_name, u.role
       FROM comments c
       JOIN users u ON c.user_id = u.id
       WHERE c.request_id = $1
       ORDER BY c.created_at ASC`,
      [requestId]
    );

    for (const comment of comments) {
      timeline.push({
        id: comment.id,
        timestamp: new Date(comment.created_at),
        type: 'comment',
        actor: {
          id: comment.user_id,
          name: `${comment.first_name} ${comment.last_name}`,
          role: comment.role as UserRole,
        },
        description: comment.via_email ? 'Commented via email' : 'Commented',
        metadata: {
          content: comment.content,
          viaEmail: comment.via_email,
        },
      });
    }

    // Sort by timestamp
    timeline.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

    return timeline;
  }

  /**
   * Map database row to Request object
   */
  private mapRowToRequest(row: any): Request {
    // Parse items if it's a string or object (from JSONB)
    let items = row.items;
    if (typeof items === 'string') {
      items = JSON.parse(items);
    } else if (typeof items === 'object' && items !== null) {
      // Already parsed by pg driver from JSONB
      items = items;
    }

    return {
      id: row.id,
      requestNumber: row.request_number,
      creatorId: row.creator_id,
      departmentId: row.department_id,
      companyId: row.company_id,
      status: row.status as RequestStatus,
      currentStep: row.current_step as WorkflowStep | null,
      items,
      notes: row.notes,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }

  /**
   * Map database row to Attachment object
   */
  private mapRowToAttachment(row: any): Attachment {
    return {
      id: row.id,
      requestId: row.request_id,
      fileName: row.file_name,
      fileUrl: row.file_url,
      fileSize: row.file_size,
      mimeType: row.mime_type,
      uploadedBy: row.uploaded_by,
      createdAt: new Date(row.created_at),
    };
  }
}
